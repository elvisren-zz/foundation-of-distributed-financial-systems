\chapter{数据持久化}




OLAP，不是OLTP
\section{object relation mismatch}

\section{数据库架构}

\section{事务的定义}
事务简化了一些异常处理模式。没有事务也是可以的。需要有更复杂的业务处理模式。

把并发伪装成非并发。

不同一致性层级的定义和实现方法。

\section{事务实现}
日志回滚

mvcc

\section{数据存储方式}
b树，列存储

\section{分布式数据库}
2PC和TCC。

证明2PC和serializability等价。

Spanner。

不再可能有store procedure了

\section{常见问题}
有了缓存和持久化存储之后，解决一个经典的先写数据库还是先写缓存的问题。

存在三个系统：缓存，业务系统，数据库。

解决问题：数据的准确查询。

假设：业务节点无状态，查询通过缓存而不是业务节点来做。这样先写缓存掉电之后数据丢失，先写数据库造成缓存更新不及时。

如果业务节点保存一部分内部最新的缓存数据，查询通过业务节点走，没有任何问题。这时候如果是多个业务节点，可能写是一个节点，查询是另一个业务节点，这时候还是会不一致。这时候可以通过查询节点的更新时间来判断是不是读到了最新的结果。这时候会碰到时间不一致的问题。通过逻辑时间可以解决时间不一致，但是需要知道当前最新的逻辑时间是多少。
