\chapter{架构设计小论}


\section{架构师的定义}

架构师没有一个公认的清晰准确的定义。架构师会做一些开发人员的工作。一般来说高级或者资深程序员的下一步发展之路是成为一位架构师，所以偶尔重操旧业写写代码是常见的事情。架构师也可能会做一些产品经理的工作，比如在设计系统架构的时候考虑对用户交互体验的影响。架构师也有可能做一些项目管理工作，追踪项目进度，收集和分配项目需要的人力和物力资源。架构师也有可能做一些销售工作，和项目拓展人员一起列席项目推介会，从系统的角度向潜在客户营销产品优势。架构师日常工作之一是画各种架构图，需要熟练使用各种绘图工具和非线性编辑工具，而这些一般都是设计师的专长。不同的公司可能都有架构师这个岗位，但是对这个岗位的定位很有可能各不相同。



但是既然都叫架构师，那么一定是有一些共性的。架构师是什么虽然不太容易定义，但是我们可以从架构师解决的问题出发尝试寻找一些共性。



首先架构师解决的是偏抽象的问题。具体的问题，比如说程序代码每一行应该怎么写，代码测试应该怎么寻找边界条件，代码的发布和上线应该遵循什么样的流程，这些都是程序员在早期需要熟练掌握的基本技能，是成为架构师的基础。只有在这些具体软件问题都能游刃有余的解决的情况下，一个程序员才能思考更深的软件开发问题，向架构师方向发展。这也是常提的道与术的区别。



其次架构师解决的问题时间跨度长。如果一个需求不需要存在很久，就不需要考虑合理的架构，也就不需要架构师。比如现在互联网创业者都在积极的寻找下一个风口，对于每一个可能的增长点都小规模的试一试，希望通过撞概率的方式来选择正确的赛道。既然是小规模的试一试，就知道项目可能不能存活很久，不需要有长远的架构设计。如果万幸之中撞到了下一个风口，成为了独角兽企业，这时候企业就需要有长期发展的计划。成熟的企业创始人会在引入投资之后马上招聘架构师进行架构升级，为接下来的用户快速增长提前打好基础。



再者架构师的解决方案一旦实施便难以更改。复杂的软件是一个围绕核心组件的生态系统。核心组件用软件的形式解决核心业务需求，周边还需要有各种辅助系统来保证业务的完整度。核心组件由于牵涉过多，其升级会牵一发而动全身。因此为了保证复杂系统的演进，架构师需要在早期全盘思考未来的各种可能发展，从中选择一条可行的道路。


最后架构师需要将系统设计的容易改变。乍一看这是一个悖论，如果架构师的长期架构设计一旦实施就难以改变，那怎么又能容易改变了呢？这是一个哲学问题，需要从哲学的角度来看。这和唯一不变的是变化是同一个道理，也是区分优秀架构师和平庸架构师的标志。系统的主体架构奠定了系统的基础，和房子的承重墙一样，起到了中流砥柱\footnote{《晏子春秋·内篇谏下》：“吾尝从君济于河，鼋衔左骖，以入砥柱之中流。”}的作用。承重墙不能敲，系统的主体架构也不能轻易改变。但是在主体架构之上可以有很多衍生的系统功能，就和房子可以有不同装修一样，对不同的需求可以有不同的实现\footnote{忒修斯之船（The Ship of Theseus）悖论：如果忒修斯的船上的木头被逐渐替换，直到所有的木头都不是原来的木头，那这艘船还是原来的那艘船吗？}。


所以总结一下。架构师解决的问题是长期抽象的问题，需要能将难以改变的系统变得容易改变。


\section{架构设计六小原则}

计算机软件是一个复杂的系统。复杂的系统总是似而不同，在细节的地方各不一样。因为细节决定成败，复杂的系统很难有屡试不爽\footnote{清·蒲松龄《聊斋志异·冷生》：“言未已，驴已蹶然伏道上，屡试不爽”。爽，差错、失败的意思。}的解法。尽管如此，解决的多了也会遗留一些经验。这些经验再加以重复验证就形成了原则。这些原则有其特殊的历史背景，不一定放之四海而皆准。但是不听老人言，吃亏在眼前，在能自行顿悟之前建议能熟诵于胸，以防不测。

\begin{center}
    \begin{pinyinscope}
    架构六则\\
    状态多具象,读写本不同。\\
    状态常迁移，一致有成本。\\
    优化守本质，变化相对论。\\
    熟诵六小计，锦囊随身行。\\
    \end{pinyinscope}
\end{center}



\subsection{状态多具象}\label{statehasmultipleview}

计算机数据分为正源和衍生两种。正源数据\footnote{正源数据即data from golden source。}指的是官方钦定的最原始的数据，所以有时候也叫原始数据。衍生数据是基于正源数据派生而来，对正源数据进行二次加工，是对正源数据的一个特殊的视角\footnote{视角即view。}。常见的衍生数据生成方式有筛选、聚合、统计等等。有一些数据属于衍生数据，但是并不那么直观。一个例子是数据库索引。数据库索引是为了加速数据查询而生成的特殊数据结构，是由数据库表衍生出来的一份数据。另一个例子是网页前端界面显示。一般的网页前端界面显示的流程是这样的：
\begin{enumerate}
    \item 后端服务器生成业务数据。 
    \item 业务数据变成与前端通讯的格式，比如json、xml等，通过网络协议发送至网页浏览器。
    \item 网页代码将数据变成特定的浏览器Javascript对象。
    \item 浏览器将Javascript对象变为计算机显卡能识别的数据。
    \item 显卡在显示器上展示数据。
\end{enumerate}

以上每一步流程都是数据的处理和加工过程。从每个加工组件的角度来看，输入是正源数据，输出是衍生数据。从上到下完整的来看，后端服务器上的是正源数据，其余数据都是衍生而来。


判断数据是正源还是衍生的办法很简单：如果数据不见了，是否能够基于其它数据重新生成出来。比如前面提到的数据库索引数据。数据库有索引的删除和表的索引重建操作，表删除了就没有了，所以索引是衍生数据，数据库表是正源数据。对于网页显示的例子，浏览器刷新之后，网页显示会先消失然后重新展示出来，但是如果后端服务器宕机就没办法再展示网页了。所以前端显示是衍生数据，后端数据是正源数据。


在架构设计中，因为衍生数据可以基于正源数据重复产生，衍生数据的容灾度较高，恢复的方法较多。相对而言正源数据只有一份，损坏之后无法轻易恢复，因此需要针对业务对容灾的需求进行精心的设计。


\subsection{读写本不同}

对于每个人来说，读是一个内容输入的过程，写是一个内容输出的过程。一般会认为这是两种不同的个人能力，不一定同时都很优秀或者都不优秀，比如有人可能阅读能力强但是写作能力弱，也有可能写作能力强但是阅读能力弱。同理，计算机的读写也是两个不同的行为。计算机的读和写的对象都是数据，但是读操作是数据的输入过程，写操作是数据的输出过程。这里提到的读写本不同的第一个不同点在于操作的不同。数据的输入和输出可能会面临不同的吞吐量、延时、容灾等需求，需要分别对待。


读写本不同的第二个不同点非常难以发觉，那就是数据的不同。在\ref{statehasmultipleview}节状态多具象里我们介绍了数据分为正源数据和衍生数据两大类。之所以会有衍生数据的一个原因是数据的使用，即数据的读取，可能需要有特殊的优化方式。为了读性能的原因需要对正源数据做一些预处理，比如建索引。所以对于数据库的例子来说写的数据是正源数据，读的数据是衍生数据，所以读写的操作是基于两份不同的数据进行的。


总结一下。读写的不同在于读写的数据不同以及数据的流向不同。在架构设计时需要将读写分开考虑，分开优化。



\subsection{状态常迁移}

\subsection{一致有成本}

\subsection{优化守本质}


\subsection{变化相对论}

