\chapter{架构设计小论}

\epigraph{The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.}{Donald Knuth \\ The Art of Computer Programming}

\section{架构师的定义}

架构师没有一个公认的清晰准确的定义。架构师会做一些开发人员的工作,一般来说高级或者资深程序员的下一步发展之路是成为一位架构师，所以偶尔重操旧业写写代码不足为奇。架构师也可能会做一些产品经理的工作，比如在设计系统架构的时候考虑对用户交互体验的影响。架构师也有可能做一些项目管理工作，追踪项目进度，收集和分配项目需要的人力和物力资源。架构师也有可能做一些销售工作，和项目拓展人员一起列席项目推介会，从系统的角度向潜在客户营销产品优势。架构师日常工作之一是画各种架构图，需要熟练使用各种绘图工具和非线性编辑工具，而这些一般都是设计师的专长。不同的公司可能都有架构师这个岗位，但是对这个岗位的定位很有可能各不相同。



但是既然都叫架构师，那么一定是有一些共性的。架构师是什么虽然不太容易定义，但是我们可以从架构师解决的问题出发尝试寻找一些共性。



首先架构师解决的是偏抽象的问题。具体的问题，比如说程序代码每一行应该怎么写，代码测试应该怎么寻找边界条件，代码的发布和上线应该遵循什么样的流程，这些都是程序员在早期需要熟练掌握的基本技能，是成为架构师的基础。只有在这些具体软件问题都能游刃有余的解决的情况下，一个程序员才能思考更深的软件开发问题，向架构师方向发展。这也是常提的道与术的区别。



其次架构师解决的问题时间跨度长。如果一个需求不需要存在很久，就不需要考虑合理的架构，也就不需要架构师。比如现在互联网创业者都在积极的寻找下一个风口，对于每一个可能的增长点都小规模的试一试，希望通过撞概率的方式来选择正确的赛道。既然是小规模的试一试，就知道项目可能不能存活很久，不需要有长远的架构设计。如果万幸之中撞到了下一个风口，成为了独角兽企业，这时候企业就需要有长期发展的计划。成熟的企业创始人会在引入投资之后马上招聘架构师进行架构升级，为接下来的用户快速增长提前打好基础。



再者架构师的解决方案一旦实施便难以更改。复杂的软件是一个围绕核心组件的生态系统。核心组件用软件的形式解决核心业务需求，周边还需要有各种辅助系统来保证业务的完整度。核心组件由于牵涉过多，其升级会牵一发而动全身。因此为了保证复杂系统的演进，架构师需要在早期全盘思考未来的各种可能发展，从中选择一条合理的道路。


最后架构师需要将系统设计的容易改变。乍一看这是一个悖论，如果架构师的长期架构设计一旦实施就难以改变，那怎么又能容易改变了呢？这是一个哲学问题，需要从哲学的角度来看。这和唯一不变的是变化是同一个道理，也是区分优秀架构师和平庸架构师的标志。系统的主体架构奠定了系统的基础，和房子的承重墙一样，起到了中流砥柱\footnote{《晏子春秋·内篇谏下》：“吾尝从君济于河，鼋衔左骖，以入砥柱之中流。”}的作用。承重墙不能敲，系统的主体架构也不能轻易改变。但是在主体架构之上可以有很多衍生的系统功能，就和房子可以有不同装修一样，对不同的需求可以有不同的实现\footnote{忒修斯之船（The Ship of Theseus）悖论：如果忒修斯的船上的木头被逐渐替换，直到所有的木头都不是原来的木头，那这艘船还是原来的那艘船吗？}。


所以总结一下。架构师解决的问题是长期抽象的问题，需要能将难以改变的系统变得容易改变。


\section{架构设计六小原则}

计算机软件是一个复杂的系统。复杂的系统总是似而不同，在宏观上类似，在细节的地方各有千秋。因为细节决定成败，复杂的系统很难有屡试不爽\footnote{清·蒲松龄《聊斋志异·冷生》：“言未已，驴已蹶然伏道上，屡试不爽”。爽，差错、失败的意思。}的解法。尽管如此，解决的多了也会遗留一些经验。这些经验再加以重复验证就形成了原则。这些原则有其特殊的历史背景，不一定放之四海而皆准。但是不听老人言，吃亏在眼前，在能自行顿悟之前建议能熟诵于胸，以防不测。

\begin{center}
    \begin{pinyinscope}
    架构六则\\
    状态多具象,读写本不同。\\
    状态常迁移，一致有成本。\\
    优化守本分，变化相对论。\\
    熟诵六小计，锦囊随身行。\\
    \end{pinyinscope}
\end{center}



\subsection{状态多具象}\label{statehasmultipleview}

计算机数据分为正源和衍生两种。正源数据\footnote{正源数据即data from golden source。}指的是官方钦定的最原始的数据，所以有时候也叫原始数据。衍生数据是基于正源数据派生而来，对正源数据进行二次加工，是对正源数据的一个特殊的视角\footnote{视角即view。}。常见的衍生数据生成方式有筛选、聚合、统计等等。有一些数据属于衍生数据，但是并不那么直观。一个例子是数据库索引。数据库索引是为了加速数据查询而生成的特殊数据结构，是由数据库表衍生出来的一份数据。另一个例子是网页前端界面显示。一般的网页前端界面显示的流程是这样的：
\begin{enumerate}
    \item 后端服务器生成业务数据。 
    \item 业务数据变成与前端通讯的格式，比如json、xml等，通过网络协议发送至网页浏览器。
    \item 网页代码将数据变成特定的浏览器Javascript对象。
    \item 浏览器将Javascript对象变为计算机显卡能识别的数据。
    \item 显卡在显示器上展示数据。
\end{enumerate}

以上每一步流程都是数据的处理和加工过程。从每个加工组件的角度来看，输入是正源数据，输出是衍生数据。从上到下完整的来看，后端服务器上的是正源数据，其余数据都是衍生而来。


判断数据是正源还是衍生的办法很简单：如果数据不见了，是否能够基于其它数据重新生成出来。比如前面提到的数据库索引数据。数据库有索引的删除和表的索引重建操作，表删除了就没有了，所以索引是衍生数据，数据库表是正源数据。对于网页显示的例子，浏览器刷新之后，网页显示会先消失然后重新展示出来，但是如果后端服务器宕机就没办法再展示网页了。所以前端显示是衍生数据，后端数据是正源数据。


在架构设计中，因为衍生数据可以基于正源数据重复产生，衍生数据的容灾度较高，恢复的方法较多。相对而言正源数据只有一份，损坏之后无法轻易恢复，因此需要针对业务对容灾的需求进行精心的设计。


\subsection{读写本不同}

对于每个人来说，读是一个内容输入的过程，写是一个内容输出的过程。一般会认为这是两种不同的个人能力，不一定同时都很优秀或者都不优秀，比如有人可能阅读能力强但是写作能力弱，也有可能写作能力强但是阅读能力弱。同理，计算机的读写也是两个不同的行为。计算机的读和写的对象都是数据，但是读操作是数据的输入过程，写操作是数据的输出过程。这里提到的读写本不同的第一个不同点在于操作的不同。数据的输入和输出可能会面临不同的吞吐量、延时、容灾等需求，需要分别对待。


读写本不同的第二个不同点非常难以发觉，那就是数据有可能也是不同的。在\fullref{statehasmultipleview} 一节里我们介绍了数据分为正源数据和衍生数据两大类。之所以会有衍生数据的一个原因是数据的使用，即数据的读取，可能需要有特殊的优化方式。为了读性能的原因需要对正源数据做一些预处理，比如建索引。所以对于数据库的例子来说写的数据是正源数据，读的数据是衍生数据，所以读写的操作是有可能基于两份不同的数据进行的。


总结一下。读写的不同在于读写的数据不同以及数据的流向不同。在架构设计时需要将读写分开考虑，分开优化。



\subsection{状态常迁移}

计算机程序会用到一些数据结构，比如List，Map，Set等等。在面向对象编程的过程中还会使用到类的对象\footnote{对象即Object。}。这些数据结构和对象其实都是一种状态\footnote{状态即State。}，计算机程序需要正确合理的维护这些状态。

通常这些状态都是在内存之中，机器一旦断电就会全部消失。所以需要将这些内存信息保存到可持久化的存储介质上，比如硬盘和网络存储。这个保存的过程其实是内存状态的迁移过程。但是硬盘也会出现机械故障，造成数据丢失。因此更为稳妥的方法是不要将鸡蛋放在一个篮子里，将硬盘的数据再备份到其它的地方。这个数据备份的过程也是状态的迁移过程。

除了解决数据丢失的问题需要状态迁移以外，状态迁移也会被用来解决物理局限。一台机器内存的大小是有限的，所以当内存里的数据大到装不下的时候，需要将内存里的数据分散到其它机器上，这些机器作为一组集群提供一个分布式的数据结构。一台机器的硬盘大小也是有上限的，同理，当硬盘不够时也可以将硬盘数据分散到由一组集群组成的分布式文件系统里。对于应用程序来说，它还是在通过同样的接口访问数据结构或者文件系统，只不过这些内容可能分散在了网络上的其它机器。



\subsection{一致有成本}

前面提到了状态常迁移。如果迁移过程中数据出了问题怎么办？比如在数据备份过程中网线断了，或者数据中心停电了。这时候需要有一套应急措施来保证在基础架构恢复之后再次启动数据备份流程。数据的重发是一种成本。

数据的全部丢失比较容易处理，相对挑战高一点的是数据部分丢失。比如在数据传输过程中掉了部分数据，或者由于宇宙射线的影响导致账户金额由正变负。这时候除了需要有数据重发功能以外还需要有数据正确性验证的功能。数据的正确性验证也是一种成本。


在分布式系统中还有一些更为复杂的情况。比如我们将数据备份至北上广三个数据中心。当我们刚发出最新的数据备份指令的时候本地数据中心掉电，完全停止工作。这时候我们需要在北上广三个数据中心中选择一个来做业务的实时切换。那么我们怎么判断选择出来的数据中心有最新的数据呢？这个问题的难点在于我们需要判断某些数据和一个无法访问的数据是否一致。这个问题的解决需要数据的发送方和接收方一起通过既定的分布式协议来解决。

我们也可以把问题简化一点。假设我们不需要判断北上广是否有最新的数据，我们只要选择当中数据最多的一个就可以了。显然可以尝试通过两两比较的方式来判断谁的数据更多。但是如果在比较的过程中网络出现了隔断，比如上海的数据中心成为了一个被隔离的信息孤岛，这时该如何处理呢？分布式系统中还有更为少见的单向通讯故障，一般是在防火墙出现错误配置的时候会出现。假设北京可以访问上海数据，上海可以访问广州数据，广州可以访问北京数据，但是上海不可以访问北京，广州不可以访问上海，北京不可以访问广州。这时每个数据中心都知道剩下两个数据中心的一个信息，但是不知道另一个的信息。这时候应该怎么判断谁的信息更全面呢？这也需要分布式协议来解决。

更为悲观的是理论科学家证明了在一定假设情况下，只要网络集群有一个节点有可能出现故障，整个集群便不可能达到一致。这就是著名的FLP结论\cite{Fischer1985}。我们会在\fullref{flpexplained}一节中详细讲解这个定理。因为机器会出故障，所以一致性的解决就不是成本高低的问题，而是不可能解决的问题了\footnote{《孟子·梁惠王上》:挟太山以超北海，语人曰‘我不能’，是诚不能也。为长者折枝,语人曰‘我不能’，是不为也，非不能也。}，换句话说想要达到一致性的成本是无限高。


所幸在实际操作过程中FLP论文中提到的假设是很容易通过一些方法来规避的，架构师还是有可能设计出一个具有一致性的软件架构。这也表明一致性的解决还有一个很高的学习成本。




\subsection{优化守本分}

如章首所引，提前优化是万恶之源。不提前的优化也需要注意。每个程序都有既定的功能，这就是在软件工程里提到的功能性需求\footnote{功能性需求即functional requirement。}。程序还有一些对于运行效率相关的要求，比如吞吐量、响应时间等。这些的学名叫非功能性需求\footnote{非功能性需求即non-functional requirement。}。优化是会改变程序的行为，但是这种改变只能影响非功能性需求，不能影响功能性需求。这是优化的一道红线，不能僭越。优化守本分\footnote{《荀子·非相》：“小辩不如见端，见端不如见本分。”}就是要守住这根红线。


在实际过程中会出现无论怎么优化，非功能性需求都无法达到的情况，比如需要达到非常高的吞吐量。这时候会通过放弃一些业务的要求来简化系统实现。常见的方法有最终一致性、事务补偿等。这时候同时出现了系统优化和功能改变，但由于功能改变是因，系统优化是果，因果关系不同，并没有违反原则。



\subsection{变化相对论}

辩证唯物主义认为，事物的运动发展是变与不变的统一。显然变与不变的相对关系是一个偏哲学的问题。由于我们是介绍实践为主，不深入做理论分析，所以在这里不做过多的阐述，只举几个例子。

一个例子是关系型数据库的查询。关系型数据库访问的方法一般是通过SQL结构化查询语句。










