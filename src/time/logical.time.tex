\section{逻辑时间}
\label{logictime}

\subsection{逻辑时间的作用}

物理时间有非常良好的性质，但是现实世界有种种因素导致我们无法完全利用这些性质。那么让我们看看究竟哪些性质是重要的、必不可缺的，哪些性质是可以放弃的。

时间的一个性质是两个时间点之间可以比大小。这是一个非常有用的信息。一旦我们可以比较两个时间的大小，我们就可以判断其发生的顺序。比如在处理数据库的读写冲突时，我们就可以知道是读操作先发生，还是写操作先发生。这个先后顺序能决定数据库应该用哪种方式来解决冲突。所以时间可以比大小这个性质需要保留。

时间的另一个性质是时间间隔有比例关系。这个貌似是不太常见的性质。比如我们知道一周的时间间隔是一天的7倍，而且无论0点如何选取，这个比例关系永远是7倍。可是这个倍数有什么用呢？所以这个比例关系是一种屠龙之技\footnote{《庄子·列御寇》:“朱泙漫学屠龙于支离益，殚千金之家，三年技成，而无所用其巧。”.}，比较鸡肋\footnote{《后汉书·杨修传》：“夫鸡肋，食之则无所得，弃之则如可惜。”。}，可以放弃。


在放弃了时间段的比例关系后，我们需要进一步思考还有哪些性质是可以放弃的。在第\ref{timeaccuracy}节我们提到过物理时间是无限精度而计算机时间是有限精度。一旦时间的衡量精度下降，如果两个事件发生的足够近，那么我们将无法判断这两个事件的发生先后顺序。既然我们做不到无限精度，有限精度又存在各种问题，还不如寻求另一种时间的表示方式来满足两个时间之间可以比大小这个功能。这便是逻辑时间。


\subsection{逻辑时间的定义}

逻辑时间是Lamport在1978年第一次完整提出的\cite{Lamport1978}。在正式定义逻辑时间前我们需要对系统做一些简单的假设。

我们假设在分布式系统中有多个节点。这些节点之间通过点对点发消息的方式来互相沟通。消息的传播需要一定的时间，而且无法预期这个时间需要多久。另外如果一个节点发了多条消息给另一个节点，这些消息可能会乱序到达，而不是保证先发先到。

与消息相关的另一个定义是事件。事件是导致节点状态变化的因素。节点有3种不同事件：
\begin{enumerate}
    \item 发送消息的事件。
    \item 接受消息的事件。
    \item 内部事件。
\end{enumerate}

对于某个消息来说，其发送和接受都会影响节点的状态。同时节点内部也会自我发生一些状态变化，导致这些内部状态变化的是内部事件。

基本概念到这里已经定义的差不多了，接下来看看事件的先后关系定义：

\begin{definition}
    对于两个事件$e_i$和$e_j$，它们之间的先后关系$\rightarrow$定义为：
    \begin{enumerate}
        \item 如果$e_i$和$e_j$发生在同一个节点，且$i < j$,那么$e_i \rightarrow e_j$。
        \item 如果$e_i$是一个消息的发送事件，$e_j$是同一个消息的接受事件，那么$e_i \rightarrow e_j$。
        \item 对于第三个事件$e_k$，如果$e_i \rightarrow e_j$，而且$e_j \rightarrow e_k$， 那么$e_i \rightarrow e_k$。
    \end{enumerate}
    
    如果$e_i$和$e_j$之间既不满足$e_i \rightarrow e_j$，也不满足$e_j \rightarrow e_i$，那么$e_i$和$e_j$之间是并发关系，记为$e_i \parallel e_j$。
\end{definition}

$\rightarrow$和$\parallel$的定义需要一些解释。在分布式系统中的各个节点只了解本地信息。所以如果单个节点内发生了两个事件$e_i$和$e_j$，它是能判断这两个事件发生时打的标记$i$和$j$来判断事件的先后顺序。

但是这个节点对其它节点发生了什么变化并不能准确的了解。唯一了解途径是通过获取其它节点发送的消息。一旦一个节点收到了另一个节点的消息，这个节点可以一定程度猜测另一个节点发生了什么，从而能确定某些事件的先后顺序。最简单的先后顺序判定是收到消息的时间一定晚于发送消息事件，所以如果$e_i$是一个消息的发送事件，$e_j$是同一个消息的接受事件，那么$e_i$一定早于$e_j$发生，因此$e_i \rightarrow e_j$。 更抽象一点来讲，每个节点像盲人摸象\footnote{《大般涅槃经》三二：“其触牙者即言象形如芦菔根，其触耳者言象如箕，其触头者言象如石，其触鼻者言象如杵，其触脚者言象如木臼，其触脊者言象如床，其触腹者言象如甕，其触尾者言象如绳。”。}一样在本地维护了对整个分布式系统的片面认识。一旦节点收到了其它节点的消息，这个节点便能更新它对整个分布式系统的认知，从而更近一步逼近最新的全局状态。虽然更新之后的认知依然是片面的，但比收到消息之前准确了一些。

先后顺序有一个良好的数学性质是它具有可传递性。所以一旦我们发现$e_i$在$e_j$之前发生，而且$e_j$在$e_k$之前发生，根据传递性规则，我们可以肯定$e_i$在$e_k$之前发生。因此如果$e_i \rightarrow e_j$，而且$e_j \rightarrow e_k$， 那么$e_i \rightarrow e_k$。

最后剩下一种情况是$e_i$和$e_j$之间没有任何可以推导出来的先后关系。这时候我们“定义”这两个事件是同时发生的。这里的同时指的是在逻辑时间的范畴内，而不是指真实的物理世界内同时发生。


说到这里我们终于可以看一下逻辑时间的定义：

\begin{definition}
    假设$(S,<)$是一个偏序集合，$E:\set{e_i}$是所有事件的集合。\cindex{逻辑时间}$C: E \rightarrow S$是一个函数，满足以下性质:
    \begin{equation}
        e_i \rightarrow e_j \Rightarrow C(e_i) < C(e_j) 
    \end{equation}
    
    \cindex{强一致性逻辑时间}$C: E \rightarrow S$需要满足以下性质：
    \begin{equation}
        e_i \rightarrow e_j \Leftrightarrow C(e_i) < C(e_j) 
    \end{equation}
\end{definition}

我们简单解释一下这些深奥的定义。逻辑时间给每个事件赋予了一个数。这些数有一个特殊性质，那就是数之间是可以比大小的。这些数构成了一个集合叫偏序集合。偏序集合的定义是集合成员之间存在大小关系，而且这些大小关系是可以传递的，但是不保证任意两个成员之间都存在大小关系。比如$\set{1,2,\dots, 1000,\dots}$是一个偏序集合，这个偏序集合里任意两个数都可以比大小。所有虚数也是一个偏序集合，只不过只有实数之间可以比大小\footnote{实数是虚数的子集。}，虚数之间以及虚数和实数之间不能比大小。

逻辑时间不是给每个事件随意的赋予一个数。这个赋予的过程需要保证大小顺序。如果两个事件之间存在先后顺序，那么它们被赋予的数之间也需要存在等价的大小顺序。强一致性逻辑时间是对这个赋予过程提的更高的要求。逻辑时间只是要求如果事件有先后，那么数值有对应的大小关系。强一致性逻辑时间要求反过来也成立，即如果两个事件被赋予的数值之间有大小关系，那么这两个事件之间存在对应的先后关系。第\ref{scalarclock}会介绍逻辑时间把事件映射到标量时间，第\ref{vectorclock}节会介绍强一致性逻辑时间把事件映射到矢量时间。


\subsection{标量时间}\label{scalarclock}

问题：
相同时间值不表示同时发生
时间大不表示发生在后面

\subsection{矢量时间}\label{vectorclock}
矢量时间是强一致的，如果不具有可比性表示是同时发生
