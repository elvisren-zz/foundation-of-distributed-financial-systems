\chapter*{引言}


\epigraph{A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable}{Leslie Lamport \\ Email message sent to a DEC SRC bulletin board at 12:23:29 PDT on 28 May 87.}


不同的软件有不同的复杂度。当人们提到一个软件要求非常高的时候，会说它会被用在金融系统中。比如现在做数据分析常用的numpy，它在介绍自己数值计算部分的时候很自豪的提到自己已经在金融系统中有所使用。那么金融系统究竟和一般的软件系统的区别在哪里呢？

金融系统的特殊之处在于它处理钱。在日常生活中一块钱和一亿块钱有很大的区别。一块钱可以随随便便拿走，一亿块钱可能一般的家用型小汽车还装不下，处理起来比较麻烦。所以在现实世界里不同额度的钱处理的方式会不一样。但是在计算机世界里，不管是一块钱还是一亿块钱都只是一个数字而已。因为都只是一个数字，计算机在处理钱的时候要分外小心，如果出了点问题，不管金额大小都会被影响。

所以当我们提到金融系统要求非常高的时候，并不是对正常的情况有特别高的要求，比如说常见的系统延时和吞吐量等等。而是对不正常的情况有非常高的要求。系统尽量不要出任何问题。如果万一出问题了，需要有办法能清楚的知道究竟是在什么时候出了什么问题。出了问题并不可怕，怕的是不知道出了什么问题。

具体细分来说金融系统有如下几点要求：
\begin{enumerate}
    \item 正确性。这是从系统实现人员来看的正确性。系统需要有合理的架构设计，有正确的实现，有相应的测试来保证代码正确率。
    \item 可解释。这是从第三方审计的角度来看的正确性。产品和业务人员需要有能力独立验证关键业务逻辑的正确性。
    \item 可靠性。系统在各种不同异常情况下下对正确性保证的量化衡量。
    \item 可维护。完整的软件系统并不是一蹴而就，而是逐步迭代和升级的。金融系统的设计需要让系统容易升级。
    \item 性能。虽然一般来说性能不是金融系统追求的目标，但是需要保证业务所需要的合理的性能要求。
\end{enumerate}

总之，金融系统要让人用的开心，用的放心。这更多的是对软件质量的要求。接下来我们从设计一个金融系统中最核心的支付系统入手，分以下章节逐步介绍金融系统的设计思路：
\begin{enumerate}
    \item 常见的方案是怎么做的。这是一个普遍采用的方案，可以快速的解决很多行业的问题，不仅仅是金融行业。
    \item 如何对金融行业做正确的建模。建模的过程是定义合理数据结构的过程。
    \item 如何对金融业务的模型做合理的操作。
    \item 如何消除数据单点，使其拥有可选的容灾性。
    \item 如何消除服务单点。
    \item 如何在消除系统单点的情况下保证数据的正确性。
    \item 单点持久化存储不够的情况下的横向扩展。
    \item 单点内存不够的情况下的业务处理。
    \item 深入理解数据持久化。各种不同的方案对正确性都有哪些不同的保证。
    \item 严格执行一次。
    \item 数据处理。
    \item 架构反思。
\end{enumerate}


需要提醒大家的是金融业务非常复杂，对应的软件系统也各有特点，不能一概而论，需要具体问题具体分析。在这里只是给大家介绍最基础的一些内容和思路，希望能起到一点抛砖引玉的作用。

